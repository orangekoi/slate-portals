"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var safe_stable_stringify_exports = {};
__export(safe_stable_stringify_exports, {
  configure: () => configure,
  stringify: () => stringify
});
module.exports = __toCommonJS(safe_stable_stringify_exports);
const { hasOwnProperty } = Object.prototype;
const stringify = configure();
const strEscapeSequencesRegExp = (
  // eslint-disable-next-line no-control-regex
  /[\u0000-\u001f\u0022\u005c\ud800-\udfff]|[\ud800-\udbff](?![\udc00-\udfff])|(?:[^\ud800-\udbff]|^)[\udc00-\udfff]/
);
function strEscape(str) {
  if (str.length < 5e3 && !strEscapeSequencesRegExp.test(str)) {
    return `"${str}"`;
  }
  return JSON.stringify(str);
}
function insertSort(array) {
  if (array.length > 200) {
    return array.sort();
  }
  for (let i = 1; i < array.length; i++) {
    const currentValue = array[i];
    let position = i;
    while (position !== 0 && array[position - 1] > currentValue) {
      array[position] = array[position - 1];
      position--;
    }
    array[position] = currentValue;
  }
  return array;
}
const typedArrayPrototypeGetSymbolToStringTag = Object.getOwnPropertyDescriptor(
  Object.getPrototypeOf(Object.getPrototypeOf(new Int8Array())),
  Symbol.toStringTag
).get;
function isTypedArrayWithEntries(value) {
  return typedArrayPrototypeGetSymbolToStringTag.call(value) !== void 0 && value.length !== 0;
}
function stringifyTypedArray(array, separator, maximumBreadth) {
  if (array.length < maximumBreadth) {
    maximumBreadth = array.length;
  }
  const whitespace = separator === "," ? "" : " ";
  let res = `"0":${whitespace}${array[0]}`;
  for (let i = 1; i < maximumBreadth; i++) {
    res += `${separator}"${i}":${whitespace}${array[i]}`;
  }
  return res;
}
function getCircularValueOption(options) {
  if (hasOwnProperty.call(options, "circularValue")) {
    const circularValue = options.circularValue;
    if (typeof circularValue === "string") {
      return `"${circularValue}"`;
    }
    if (circularValue == null) {
      return circularValue;
    }
    if (circularValue === Error || circularValue === TypeError) {
      return {
        toString() {
          throw new TypeError("Converting circular structure to JSON");
        }
      };
    }
    throw new TypeError(
      'The "circularValue" argument must be of type string or the value null or undefined'
    );
  }
  return '"[Circular]"';
}
function getBooleanOption(options, key) {
  let value;
  if (hasOwnProperty.call(options, key)) {
    value = options[key];
    if (typeof value !== "boolean") {
      throw new TypeError(`The "${key}" argument must be of type boolean`);
    }
  }
  return value === void 0 ? true : value;
}
function getPositiveIntegerOption(options, key) {
  let value;
  if (hasOwnProperty.call(options, key)) {
    value = options[key];
    if (typeof value !== "number") {
      throw new TypeError(`The "${key}" argument must be of type number`);
    }
    if (!Number.isInteger(value)) {
      throw new TypeError(`The "${key}" argument must be an integer`);
    }
    if (value < 1) {
      throw new RangeError(`The "${key}" argument must be >= 1`);
    }
  }
  return value === void 0 ? Infinity : value;
}
function getItemCount(number) {
  if (number === 1) {
    return "1 item";
  }
  return `${number} items`;
}
function getUniqueReplacerSet(replacerArray) {
  const replacerSet = /* @__PURE__ */ new Set();
  for (const value of replacerArray) {
    if (typeof value === "string" || typeof value === "number") {
      replacerSet.add(String(value));
    }
  }
  return replacerSet;
}
function getStrictOption(options) {
  if (hasOwnProperty.call(options, "strict")) {
    const value = options.strict;
    if (typeof value !== "boolean") {
      throw new TypeError('The "strict" argument must be of type boolean');
    }
    if (value) {
      return (value2) => {
        let message = `Object can not safely be stringified. Received type ${typeof value2}`;
        if (typeof value2 !== "function") message += ` (${value2.toString()})`;
        throw new Error(message);
      };
    }
  }
}
function configure(options) {
  options = { ...options };
  const fail = getStrictOption(options);
  if (fail) {
    if (options.bigint === void 0) {
      options.bigint = false;
    }
    if (!("circularValue" in options)) {
      options.circularValue = Error;
    }
  }
  const circularValue = getCircularValueOption(options);
  const bigint = getBooleanOption(options, "bigint");
  const deterministic = getBooleanOption(options, "deterministic");
  const maximumDepth = getPositiveIntegerOption(options, "maximumDepth");
  const maximumBreadth = getPositiveIntegerOption(options, "maximumBreadth");
  function stringifyFnReplacer(key, parent, stack, replacer, spacer, indentation) {
    let value = parent[key];
    if (typeof value === "object" && value !== null && typeof value.toJSON === "function") {
      value = value.toJSON(key);
    }
    value = replacer.call(parent, key, value);
    switch (typeof value) {
      case "string":
        return strEscape(value);
      case "object": {
        if (value === null) {
          return "null";
        }
        if (stack.includes(value)) {
          return circularValue;
        }
        let res = "";
        let join = ",";
        const originalIndentation = indentation;
        if (Array.isArray(value)) {
          if (value.length === 0) {
            return "[]";
          }
          if (maximumDepth < stack.length + 1) {
            return '"[Array]"';
          }
          stack.push(value);
          if (spacer !== "") {
            indentation += spacer;
            res += `
${indentation}`;
            join = `,
${indentation}`;
          }
          const maximumValuesToStringify = Math.min(value.length, maximumBreadth);
          let i = 0;
          for (; i < maximumValuesToStringify - 1; i++) {
            const tmp2 = stringifyFnReplacer(String(i), value, stack, replacer, spacer, indentation);
            res += tmp2 === void 0 ? "null" : tmp2;
            res += join;
          }
          const tmp = stringifyFnReplacer(String(i), value, stack, replacer, spacer, indentation);
          res += tmp === void 0 ? "null" : tmp;
          if (value.length - 1 > maximumBreadth) {
            const removedKeys = value.length - maximumBreadth - 1;
            res += `${join}"... ${getItemCount(removedKeys)} not stringified"`;
          }
          if (spacer !== "") {
            res += `
${originalIndentation}`;
          }
          stack.pop();
          return `[${res}]`;
        }
        let keys = Object.keys(value);
        const keyLength = keys.length;
        if (keyLength === 0) {
          return "{}";
        }
        if (maximumDepth < stack.length + 1) {
          return '"[Object]"';
        }
        let whitespace = "";
        let separator = "";
        if (spacer !== "") {
          indentation += spacer;
          join = `,
${indentation}`;
          whitespace = " ";
        }
        const maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth);
        if (deterministic && !isTypedArrayWithEntries(value)) {
          keys = insertSort(keys);
        }
        stack.push(value);
        for (let i = 0; i < maximumPropertiesToStringify; i++) {
          const key2 = keys[i];
          const tmp = stringifyFnReplacer(key2, value, stack, replacer, spacer, indentation);
          if (tmp !== void 0) {
            res += `${separator}${strEscape(key2)}:${whitespace}${tmp}`;
            separator = join;
          }
        }
        if (keyLength > maximumBreadth) {
          const removedKeys = keyLength - maximumBreadth;
          res += `${separator}"...":${whitespace}"${getItemCount(removedKeys)} not stringified"`;
          separator = join;
        }
        if (spacer !== "" && separator.length > 1) {
          res = `
${indentation}${res}
${originalIndentation}`;
        }
        stack.pop();
        return `{${res}}`;
      }
      case "number":
        return isFinite(value) ? String(value) : fail ? fail(value) : "null";
      case "boolean":
        return value === true ? "true" : "false";
      case "undefined":
        return void 0;
      case "bigint":
        if (bigint) {
          return String(value);
        }
      // fallthrough
      default:
        return fail ? fail(value) : void 0;
    }
  }
  function stringifyArrayReplacer(key, value, stack, replacer, spacer, indentation) {
    if (typeof value === "object" && value !== null && typeof value.toJSON === "function") {
      value = value.toJSON(key);
    }
    switch (typeof value) {
      case "string":
        return strEscape(value);
      case "object": {
        if (value === null) {
          return "null";
        }
        if (stack.includes(value)) {
          return circularValue;
        }
        const originalIndentation = indentation;
        let res = "";
        let join = ",";
        if (Array.isArray(value)) {
          if (value.length === 0) {
            return "[]";
          }
          if (maximumDepth < stack.length + 1) {
            return '"[Array]"';
          }
          stack.push(value);
          if (spacer !== "") {
            indentation += spacer;
            res += `
${indentation}`;
            join = `,
${indentation}`;
          }
          const maximumValuesToStringify = Math.min(value.length, maximumBreadth);
          let i = 0;
          for (; i < maximumValuesToStringify - 1; i++) {
            const tmp2 = stringifyArrayReplacer(String(i), value[i], stack, replacer, spacer, indentation);
            res += tmp2 === void 0 ? "null" : tmp2;
            res += join;
          }
          const tmp = stringifyArrayReplacer(String(i), value[i], stack, replacer, spacer, indentation);
          res += tmp === void 0 ? "null" : tmp;
          if (value.length - 1 > maximumBreadth) {
            const removedKeys = value.length - maximumBreadth - 1;
            res += `${join}"... ${getItemCount(removedKeys)} not stringified"`;
          }
          if (spacer !== "") {
            res += `
${originalIndentation}`;
          }
          stack.pop();
          return `[${res}]`;
        }
        stack.push(value);
        let whitespace = "";
        if (spacer !== "") {
          indentation += spacer;
          join = `,
${indentation}`;
          whitespace = " ";
        }
        let separator = "";
        for (const key2 of replacer) {
          const tmp = stringifyArrayReplacer(key2, value[key2], stack, replacer, spacer, indentation);
          if (tmp !== void 0) {
            res += `${separator}${strEscape(key2)}:${whitespace}${tmp}`;
            separator = join;
          }
        }
        if (spacer !== "" && separator.length > 1) {
          res = `
${indentation}${res}
${originalIndentation}`;
        }
        stack.pop();
        return `{${res}}`;
      }
      case "number":
        return isFinite(value) ? String(value) : fail ? fail(value) : "null";
      case "boolean":
        return value === true ? "true" : "false";
      case "undefined":
        return void 0;
      case "bigint":
        if (bigint) {
          return String(value);
        }
      // fallthrough
      default:
        return fail ? fail(value) : void 0;
    }
  }
  function stringifyIndent(key, value, stack, spacer, indentation) {
    switch (typeof value) {
      case "string":
        return strEscape(value);
      case "object": {
        if (value === null) {
          return "null";
        }
        if (typeof value.toJSON === "function") {
          value = value.toJSON(key);
          if (typeof value !== "object") {
            return stringifyIndent(key, value, stack, spacer, indentation);
          }
          if (value === null) {
            return "null";
          }
        }
        if (stack.includes(value)) {
          return circularValue;
        }
        const originalIndentation = indentation;
        if (Array.isArray(value)) {
          if (value.length === 0) {
            return "[]";
          }
          if (maximumDepth < stack.length + 1) {
            return '"[Array]"';
          }
          stack.push(value);
          indentation += spacer;
          let res2 = `
${indentation}`;
          const join2 = `,
${indentation}`;
          const maximumValuesToStringify = Math.min(value.length, maximumBreadth);
          let i = 0;
          for (; i < maximumValuesToStringify - 1; i++) {
            const tmp2 = stringifyIndent(String(i), value[i], stack, spacer, indentation);
            res2 += tmp2 === void 0 ? "null" : tmp2;
            res2 += join2;
          }
          const tmp = stringifyIndent(String(i), value[i], stack, spacer, indentation);
          res2 += tmp === void 0 ? "null" : tmp;
          if (value.length - 1 > maximumBreadth) {
            const removedKeys = value.length - maximumBreadth - 1;
            res2 += `${join2}"... ${getItemCount(removedKeys)} not stringified"`;
          }
          res2 += `
${originalIndentation}`;
          stack.pop();
          return `[${res2}]`;
        }
        let keys = Object.keys(value);
        const keyLength = keys.length;
        if (keyLength === 0) {
          return "{}";
        }
        if (maximumDepth < stack.length + 1) {
          return '"[Object]"';
        }
        indentation += spacer;
        const join = `,
${indentation}`;
        let res = "";
        let separator = "";
        let maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth);
        if (isTypedArrayWithEntries(value)) {
          res += stringifyTypedArray(value, join, maximumBreadth);
          keys = keys.slice(value.length);
          maximumPropertiesToStringify -= value.length;
          separator = join;
        }
        if (deterministic) {
          keys = insertSort(keys);
        }
        stack.push(value);
        for (let i = 0; i < maximumPropertiesToStringify; i++) {
          const key2 = keys[i];
          const tmp = stringifyIndent(key2, value[key2], stack, spacer, indentation);
          if (tmp !== void 0) {
            res += `${separator}${strEscape(key2)}: ${tmp}`;
            separator = join;
          }
        }
        if (keyLength > maximumBreadth) {
          const removedKeys = keyLength - maximumBreadth;
          res += `${separator}"...": "${getItemCount(removedKeys)} not stringified"`;
          separator = join;
        }
        if (separator !== "") {
          res = `
${indentation}${res}
${originalIndentation}`;
        }
        stack.pop();
        return `{${res}}`;
      }
      case "number":
        return isFinite(value) ? String(value) : fail ? fail(value) : "null";
      case "boolean":
        return value === true ? "true" : "false";
      case "undefined":
        return void 0;
      case "bigint":
        if (bigint) {
          return String(value);
        }
      // fallthrough
      default:
        return fail ? fail(value) : void 0;
    }
  }
  function stringifySimple(key, value, stack) {
    switch (typeof value) {
      case "string":
        return strEscape(value);
      case "object": {
        if (value === null) {
          return "null";
        }
        if (typeof value.toJSON === "function") {
          value = value.toJSON(key);
          if (typeof value !== "object") {
            return stringifySimple(key, value, stack);
          }
          if (value === null) {
            return "null";
          }
        }
        if (stack.includes(value)) {
          return circularValue;
        }
        let res = "";
        if (Array.isArray(value)) {
          if (value.length === 0) {
            return "[]";
          }
          if (maximumDepth < stack.length + 1) {
            return '"[Array]"';
          }
          stack.push(value);
          const maximumValuesToStringify = Math.min(value.length, maximumBreadth);
          let i = 0;
          for (; i < maximumValuesToStringify - 1; i++) {
            const tmp2 = stringifySimple(String(i), value[i], stack);
            res += tmp2 === void 0 ? "null" : tmp2;
            res += ",";
          }
          const tmp = stringifySimple(String(i), value[i], stack);
          res += tmp === void 0 ? "null" : tmp;
          if (value.length - 1 > maximumBreadth) {
            const removedKeys = value.length - maximumBreadth - 1;
            res += `,"... ${getItemCount(removedKeys)} not stringified"`;
          }
          stack.pop();
          return `[${res}]`;
        }
        let keys = Object.keys(value);
        const keyLength = keys.length;
        if (keyLength === 0) {
          return "{}";
        }
        if (maximumDepth < stack.length + 1) {
          return '"[Object]"';
        }
        let separator = "";
        let maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth);
        if (isTypedArrayWithEntries(value)) {
          res += stringifyTypedArray(value, ",", maximumBreadth);
          keys = keys.slice(value.length);
          maximumPropertiesToStringify -= value.length;
          separator = ",";
        }
        if (deterministic) {
          keys = insertSort(keys);
        }
        stack.push(value);
        for (let i = 0; i < maximumPropertiesToStringify; i++) {
          const key2 = keys[i];
          const tmp = stringifySimple(key2, value[key2], stack);
          if (tmp !== void 0) {
            res += `${separator}${strEscape(key2)}:${tmp}`;
            separator = ",";
          }
        }
        if (keyLength > maximumBreadth) {
          const removedKeys = keyLength - maximumBreadth;
          res += `${separator}"...":"${getItemCount(removedKeys)} not stringified"`;
        }
        stack.pop();
        return `{${res}}`;
      }
      case "number":
        return isFinite(value) ? String(value) : fail ? fail(value) : "null";
      case "boolean":
        return value === true ? "true" : "false";
      case "undefined":
        return void 0;
      case "bigint":
        if (bigint) {
          return String(value);
        }
      // fallthrough
      default:
        return fail ? fail(value) : void 0;
    }
  }
  function stringify2(value, replacer, space) {
    if (arguments.length > 1) {
      let spacer = "";
      if (typeof space === "number") {
        spacer = " ".repeat(Math.min(space, 10));
      } else if (typeof space === "string") {
        spacer = space.slice(0, 10);
      }
      if (replacer != null) {
        if (typeof replacer === "function") {
          return stringifyFnReplacer("", { "": value }, [], replacer, spacer, "");
        }
        if (Array.isArray(replacer)) {
          return stringifyArrayReplacer("", value, [], getUniqueReplacerSet(replacer), spacer, "");
        }
      }
      if (spacer.length !== 0) {
        return stringifyIndent("", value, [], spacer, "");
      }
    }
    return stringifySimple("", value, []);
  }
  return stringify2;
}
