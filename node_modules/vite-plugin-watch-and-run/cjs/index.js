"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var index_exports = {};
__export(index_exports, {
  kindWithPath: () => kindWithPath,
  kindWithoutPath: () => kindWithoutPath,
  watchAndRun: () => watchAndRun
});
module.exports = __toCommonJS(index_exports);
var import_child_process = require("child_process");
var import_micromatch = __toESM(require("micromatch"), 1);
var import_helpers = require("@kitql/helpers");
const nbOverlap = (a1, a2) => {
  return a1.filter((value) => a2?.includes(value)).length;
};
const kindWithPath = ["add", "addDir", "change", "unlink", "unlinkDir"];
const kindWithoutPath = ["all", "error", "raw", "ready"];
function checkConf(params) {
  if (!Array.isArray(params)) {
    throw new Error("plugin watchAndRun, `params` needs to be an array.");
  }
  const paramsChecked = [];
  for (const paramRow of params) {
    const param = {
      kind: paramRow.watchKind ?? ["add", "change", "unlink"],
      run: paramRow.run,
      delay: paramRow.delay ?? 300,
      isRunning: false,
      name: paramRow.name,
      logs: paramRow.logs ?? ["trigger", "streamData", "streamError", "end"],
      watch: paramRow.watch,
      shell: paramRow.shell ?? true,
      watchFile: paramRow.watchFile,
      formatErrors: paramRow.formatErrors
    };
    if (["ADD", "CHANGE", "DELETE"].includes(param.kind || "")) {
      throw new Error(
        "BREAKING: ADD, CHANGE, DELETE were renamed add, change, unlink. Please update your config."
      );
    }
    if (nbOverlap(kindWithPath, param.kind) !== 0 && !param.watch && !param.watchFile) {
      throw new Error("plugin watch-and-run, `watch` or `watchFile` is missing.");
    }
    if (!param.run) {
      throw new Error("plugin watch-and-run, `run` is missing.");
    }
    paramsChecked.push(param);
  }
  return paramsChecked;
}
async function shouldRun(absolutePath, watchKind, watchAndRunConf) {
  for (const info of watchAndRunConf) {
    if (!absolutePath || !info.watchFile && !info.watch) {
      continue;
    }
    const isWatched = info.kind.includes(watchKind);
    let isPathMatching = false;
    if (info.watchFile) {
      isPathMatching = await info.watchFile(absolutePath);
    } else if (info.watch) {
      isPathMatching = import_micromatch.default.isMatch(absolutePath, info.watch);
    }
    const isWatchKindWithoutPath = kindWithoutPath.includes(watchKind);
    if (!info.isRunning && isWatched && (isPathMatching || isWatchKindWithoutPath)) {
      return info;
    }
  }
  return null;
}
function formatLog(str, name) {
  return `${name ? (0, import_helpers.magenta)(`[${name}]`) : ""} ${str}`;
}
async function watcher(server, absolutePath, watchKind, watchAndRunConf) {
  const info = await shouldRun(absolutePath, watchKind, watchAndRunConf);
  if (info) {
    info.isRunning = true;
    if (info.logs.includes("trigger")) {
      const message = [`Watch ${(0, import_helpers.cyan)(watchKind)}`];
      if (info.watch && absolutePath) {
        message.push((0, import_helpers.green)(absolutePath.replaceAll(process.cwd(), "")));
      }
      if (typeof info.run === "string") {
        message.push(`and run ${(0, import_helpers.green)(info.run)}`);
      }
      message.push(`${(0, import_helpers.cyan)(info.delay + "ms")}`);
      log.success(message.join(" "));
    }
    setTimeout(async () => {
      if (typeof info.run === "function") {
        const promise = info.run(server, absolutePath);
        try {
          if (promise) {
            await promise;
          }
        } catch (e) {
          if (info.formatErrors) {
            info.formatErrors(e);
          } else {
            throw e;
          }
        }
        info.isRunning = false;
        return;
      }
      const child = (0, import_child_process.spawn)(info.run, [], { shell: info.shell });
      if (info.logs.includes("streamData")) {
        child.stdout.on("data", (data) => {
          process.stdout.write(formatLog(data.toString(), info.name ?? ""));
        });
      }
      if (info.logs.includes("streamError")) {
        child.stderr.on("data", (data) => {
          process.stdout.write(formatLog(data.toString(), info.name ?? ""));
        });
      }
      child.on("close", (code) => {
        if (info.logs.includes("end")) {
          const message = [`Finished`];
          if (info.name) {
            message.push(`${(0, import_helpers.magenta)(info.name)}`);
          }
          if (code === 0) {
            message.push((0, import_helpers.green)("successfully"));
            log.success(message.join(" "));
          } else {
            message.push(`with some ${(0, import_helpers.red)("errors")}!`);
            log.error(message.join(" "));
          }
        }
        info.isRunning = false;
      });
      return;
    }, info.delay);
  }
  return;
}
const log = new import_helpers.Log("Watch-and-Run");
const watchAndRun = (params) => {
  return {
    name: "watch-and-run",
    // jsut for testing purposes
    getCheckedConf() {
      return checkConf(params);
    },
    async configureServer(server) {
      const watchAndRunConf = checkConf(params);
      for (const conf of watchAndRunConf) {
        if (conf.watch) {
          server.watcher.add(conf.watch);
        }
      }
      for (const kind of kindWithPath) {
        const _watcher = async (absolutePath) => watcher(server, absolutePath, kind, watchAndRunConf);
        server.watcher.on(kind, _watcher);
      }
      for (const kind of kindWithoutPath) {
        const _watcher = () => watcher(server, null, kind, watchAndRunConf);
        server.watcher.on(kind, _watcher);
      }
    }
  };
};
